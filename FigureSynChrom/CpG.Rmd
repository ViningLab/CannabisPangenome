---
title: "CpG"
output: html_document
date: "2023-04-20"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.align = "center")
```

## Read in BED file

```{r}
bed <- read.table("../SODLa.filtered_CG_wins.bed", sep = "\t")
my_header <- scan( file = "../SODLa.filtered_CG_wins.bed", what = "character", sep = "\n", skip = 1, nlines = 1 )
#sub("# ", "", my_header)
colnames(bed) <- c('chrom', 'chromStart', 'chromEnd', 'name', 'score', 'strand', 'thickStart', 'thickEnd', 'itemRGB', 'blockCount', 'blockSizes')
#bed[1:3, ]
#bed[1:3, 'blockCount']/(bed[1:3, 'blockSizes']/2)
```


## Compare blockCount and score


```{r}
library(ggplot2)
p <- ggplot( data = bed, mapping = aes( x = blockCount, y = score, color = chrom) )
p <- p + geom_point( aes( size = 2 ) )
p <- p + geom_smooth(method=lm, se=FALSE)
p <- p + theme_bw()
p
```


Note that chromosomes have been scaled independently of one another as opposed to a genome wide scaling.


This plot demonstrates a linear relationship among 'blockCount' and 'score'.
This shows that the scaling does not affect any relationship among these two measures with other comparisons.


## Read in per chromosome nucleotide content

```{r}
nucs <- read.csv("../FigureSideo/SODLa.softmasked_nuccomp.csv")
nucs <- nucs[1:10, ]
nucs[1:3, ]
```


## Calculate and expected 'CG' motif frequency based on nucleotide content.


```{r}
expectedCG <- rowSums(nucs[, c("c" ,"C")])/rowSums(nucs[, c("a", "A", "c" ,"C", "g", "G", "t", "T")]) * rowSums(nucs[, c("g" ,"G")])/rowSums(nucs[, c("a", "A", "c" ,"C", "g", "G", "t", "T")])
```



$$
eCG = pC * pG
$$


**pC** = Per position frequency of C = count of C divided by count of ACGT    
**pG** = Per position frequency of G = count of G divided by count of ACGT    
**eCG** = expected frequency of CG (units?)    

Is **eCG** per position?
Because 'CG' is a 2 bp motif I feel we need a modifier.
A value of 2 may be a good start, because the number of positions divided by the motif length may accommodate for the 2 bp motif not being available at all positions.
This may be 'overly severe', but seems like a good starting point.


```{r, fig.width=10}
plot( 1:nrow(bed), bed[ , 'blockCount'],
      col = as.factor(bed[ , 'chrom']),
      pch = 20, ylab = "blockCount", xlab = "Window")
abline( h = mean(expectedCG) * 1e6 / 1:2, lty = 3, lwd = 2, col = "#B22222" )
```


The upper red line (~ 30,000) is the unmodified expectation.
The lower red line (~15,000) is the expectation modified with a 2 in order to divide the total number of positions (1e6) by the motif length.
The lower line appears closer to the observed values, but may require refinement.


```{r, fig.width=10}
plot( 1:nrow(bed), bed[ , 'blockCount'] / (mean(expectedCG) * 1e6 / 2),
      col = as.factor(bed[ , 'chrom']),
      pch = 20, ylab = "Observed/expected", xlab = "Window")
abline( h = 1, lty = 3, lwd = 2, col = "#B22222" )
```


